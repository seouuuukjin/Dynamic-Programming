11053 - 가장 긴 증가하는 부분수열

https://www.acmicpc.net/problem/11053

```c++
//lis = longest increasing subsequece
#include <iostream>
#include <algorithm>
using namespace std;
int lis_len[1111] = {1,};  // 주의~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//배열초기화 방법 오류
int arr[1111] = {0};

int main() {
	int n;
	scanf("%d", &n);
	for(int i=0; i<n; i++)
		scanf("%d", &arr[i]);
	for(int i=0; i<n; i++)
		printf("%d ", lis_len[i]);
	cout << endl;
	for(int i =1; i<=n; i++){ // i가 0일때는 무조건 lis_len[i] = 1이다.
		for(int j = i-1; j>=0; j--){
			if(arr[i] > arr[j])
				lis_len[i] = max(lis_len[j]+1, lis_len[i]);
		}
	}
	for(int i=0; i<n; i++)
		printf("%d ", lis_len[i]);
	cout << endl;
	printf("%d", *max_element(lis_len, lis_len+n));
	return 0;
}
```
밑에가 완성본
```c++
#include <iostream>
#include <algorithm>
using namespace std;
//lis = longest increasing subsequece

int lis_len[1111]; 
int arr[1111] = {0};

int main() {
	int n;
	scanf("%d", &n);
	for(int i=0; i<n; i++)
		lis_len[i] = 1;
	for(int i=0; i<n; i++)
		scanf("%d", &arr[i]);
	for(int i =1; i<=n; i++){ // i가 0일때는 무조건 lis_len[i] = 1이다.
		for(int j = i-1; j>=0; j--){
			if(arr[i] > arr[j])
				lis_len[i] = max(lis_len[j]+1, lis_len[i]);
		}
	}
	printf("%d", *max_element(lis_len, lis_len+n));
	return 0;
}
```
<p>
주의사항: 배열을 초기화 할때에는 저렇게 {1,}; 한다고 해서 배열 전체가 1로 초기화 되지 않는다.<br>
그리고 또 그렇다고 cstring 헤더의 memset함수를 쓸 때 역시 주의점이 있다.<br>
<p>1번주의점<br>
1Bytes 변수(char, unsigned char 등)를 제외한 변수를 초기화 할 때에는 
0이외의 값으로 초기화를 하면 안된다.</p>
<p>1번 이유
	
```c++
int n;
memset(&n, 1, sizeof(int));
```
이렇게 쓰면 Byte단위로 초기화가 되어서 n= [00000001000000010000000100000001] = 16843009 이라는 값이 들어가게 된다.<br>
따라서 1Byte의 변수를 제외하고는 모두 0 으로 초기화 할때만, memset 사용 할것.
</p>
				
</p>
<p>
발전사항;<br>
~><br>
alogorithm 헤더파일을 쓰지 않고(max_element함수역시 사용하지 않겟다는 소리), 그냥 하나하나 비교해서 최대값얻어도 나쁘지 않을거같음.<br>
~><br>
추가<br>
</p>

<br>
